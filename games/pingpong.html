<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Ping Pong — Play on PC & Mobile</title>
    <style>
        :root {
            --bg: #0b1220;
            --panel: #0f1a2b;
            --accent: #ffd166;
            --muted: #8fa3bf;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, var(--bg), #07101a);
            color: #fff
        }

        .wrap {
            width: 100%;
            max-width: 920px;
            margin: 20px;
            padding: 16px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6)
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px
        }

        h1 {
            font-size: 18px;
            margin: 0;
            color: var(--accent)
        }

        .info {
            font-size: 13px;
            color: var(--muted)
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.03));
            touch-action: none
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 6px 10px;
            border-radius: 8px;
            color: var(--muted);
            font-size: 13px
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        .hint {
            margin-left: auto;
            color: var(--muted);
            font-size: 13px
        }

        /* On-screen mobile buttons */
        .mobile-controls {
            display: none;
            gap: 8px
        }

        .mobile-controls .btn {
            padding: 10px 14px
        }

        @media (pointer:coarse),
        (max-width:720px) {
            .mobile-controls {
                display: flex
            }
        }

        .back-btn-2 {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            font-size: 14px;
            background: #4a90e2;
            border: none;
            border-radius: 20px;
            color: white;
            text-decoration: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
        }

        .back-btn-2:hover {
            background: #357ae8;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <div class="wrap" role="main">
        <header>
            <h1>Ping-Pong</h1>
            <div class="info">Move: mouse/touch or arrows / W S • Pause: Space • Restart: R</div>
        </header>
        <a href="../index.html" class="back-btn-2">← Back</a>

        <canvas id="game"></canvas>

        <div class="controls">
            <button id="pauseBtn" class="btn">Pause</button>
            <button id="restartBtn" class="btn">Restart</button>
            <div class="mobile-controls">
                <button id="upBtn" class="btn">↑ Up</button>
                <button id="downBtn" class="btn">↓ Down</button>
            </div>
            <div class="hint small">First to 7 wins • Tap and drag on mobile</div>
        </div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d', { alpha: false });

            // Virtual game size (keeps physics stable regardless of display size)
            const GAME_W = 900;
            const GAME_H = 600;

            // Game state
            let scale = 1;
            let lastTime = 0;
            let running = true;
            let leftScore = 0;
            let rightScore = 0;
            const WIN_SCORE = 7;

            // Paddles & ball
            const paddle = {
                w: 14,
                h: 100,
                x: 30,
                y: GAME_H / 2 - 50,
                speed: 800  // px/s for keyboard movement
            };
            const paddleRight = {
                w: 14,
                h: 100,
                x: GAME_W - 30 - 14,
                y: GAME_H / 2 - 50,
                speed: 500
            };
            const ball = {
                x: GAME_W / 2,
                y: GAME_H / 2,
                r: 10,
                speed: 480, // initial speed px/s
                vx: 300,
                vy: 180
            };

            // Input
            const keys = { up: false, down: false };
            let pointerY = null; // for mouse/touch control

            // Responsive canvas sizing — keep virtual aspect and scale
            function resizeCanvas() {
                const containerW = Math.min(window.innerWidth - 40, 920);
                // full responsive width
                canvas.style.width = containerW + "px";
                // compute scale from CSS width to virtual width
                scale = containerW / GAME_W;
                canvas.width = GAME_W;
                canvas.height = GAME_H;
                // Make canvas render crisp on high-DPI displays
                const dpr = window.devicePixelRatio || 1;
                canvas.style.height = (GAME_H * scale) + "px";
                canvas.width = Math.round(GAME_W * dpr);
                canvas.height = Math.round(GAME_H * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }

            // Draw utilities
            function drawRoundRect(x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); ctx.fill(); }
            function drawNet() {
                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,0.07)';
                const step = 24;
                for (let y = 0; y < GAME_H; y += step) {
                    ctx.fillRect(GAME_W / 2 - 2, y + 6, 4, step - 10);
                }
                ctx.restore();
            }

            // Reset ball to center, serve towards last scorer (randomize a bit)
            function resetBall(towardsRight = true) {
                ball.x = GAME_W / 2;
                ball.y = GAME_H / 2;
                ball.speed = 480;
                const angle = (Math.random() * 0.6 - 0.3); // -0.3..0.3 radians
                const dir = towardsRight ? 1 : -1;
                ball.vx = Math.cos(angle) * ball.speed * dir;
                ball.vy = Math.sin(angle) * ball.speed;
            }

            // Basic rectangle collision check
            function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
                return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
            }

            // Game update
            function update(dt) {
                if (!running) return;

                // Player paddle (keyboard)
                if (keys.up) paddle.y -= paddle.speed * dt;
                if (keys.down) paddle.y += paddle.speed * dt;

                // Pointer control overrides keyboard if present
                if (pointerY !== null) {
                    // pointerY is in game coordinates
                    const target = pointerY - paddle.h / 2;
                    // Smooth interpolate to make control feel nicer
                    paddle.y += (target - paddle.y) * Math.min(12 * dt, 1);
                }

                // Bound paddles
                paddle.y = Math.max(0, Math.min(GAME_H - paddle.h, paddle.y));
                paddleRight.y = Math.max(0, Math.min(GAME_H - paddleRight.h, paddleRight.y));

                // Simple AI for right paddle: follow ball with some max speed and inertia
                const desired = ball.y - paddleRight.h / 2;
                const diff = desired - paddleRight.y;
                paddleRight.y += Math.sign(diff) * Math.min(Math.abs(diff), paddleRight.speed * dt);

                // Move ball
                ball.x += ball.vx * dt;
                ball.y += ball.vy * dt;

                // Top/bottom collisions
                if (ball.y - ball.r < 0) {
                    ball.y = ball.r;
                    ball.vy *= -1;
                } else if (ball.y + ball.r > GAME_H) {
                    ball.y = GAME_H - ball.r;
                    ball.vy *= -1;
                }

                // Paddle collisions
                // Left paddle
                if (ball.vx < 0) {
                    const px = paddle.x, py = paddle.y, pw = paddle.w, ph = paddle.h;
                    if (rectsIntersect(ball.x - ball.r, ball.y - ball.r, ball.r * 2, ball.r * 2, px, py, pw, ph)) {
                        ball.x = px + pw + ball.r; // prevent sticking
                        // reflect and add spin based on where the ball hit the paddle
                        const relative = (ball.y - (py + ph / 2)) / (ph / 2); // -1..1
                        const bounceAngle = relative * (Math.PI / 3); // max 60 degrees
                        const speedUp = 1.06;
                        ball.speed *= speedUp;
                        const dir = 1;
                        ball.vx = Math.cos(bounceAngle) * ball.speed * dir;
                        ball.vy = Math.sin(bounceAngle) * ball.speed;
                    }
                } else {
                    // Right paddle
                    const px = paddleRight.x, py = paddleRight.y, pw = paddleRight.w, ph = paddleRight.h;
                    if (rectsIntersect(ball.x - ball.r, ball.y - ball.r, ball.r * 2, ball.r * 2, px, py, pw, ph)) {
                        ball.x = px - ball.r;
                        const relative = (ball.y - (py + ph / 2)) / (ph / 2);
                        const bounceAngle = relative * (Math.PI / 3);
                        const speedUp = 1.06;
                        ball.speed *= speedUp;
                        const dir = -1;
                        ball.vx = Math.cos(bounceAngle) * ball.speed * dir;
                        ball.vy = Math.sin(bounceAngle) * ball.speed;
                    }
                }

                // Score check
                if (ball.x < -50) { // right scores
                    rightScore++;
                    checkWin();
                    resetBall(true);
                    running = false;
                    setTimeout(() => running = true, 400); // short pause after score
                } else if (ball.x > GAME_W + 50) { // left scores
                    leftScore++;
                    checkWin();
                    resetBall(false);
                    running = false;
                    setTimeout(() => running = true, 400);
                }
            }

            function checkWin() {
                if (leftScore >= WIN_SCORE || rightScore >= WIN_SCORE) {
                    running = false;
                }
            }

            // Render
            function render() {
                // background
                ctx.fillStyle = '#061019';
                ctx.fillRect(0, 0, GAME_W, GAME_H);

                // table
                ctx.fillStyle = '#071427';
                drawRoundRect(10, 10, GAME_W - 20, GAME_H - 20, 10);

                // net
                drawNet();

                // paddles
                ctx.fillStyle = '#ffffff';
                drawRoundRect(paddle.x, paddle.y, paddle.w, paddle.h, 6);
                drawRoundRect(paddleRight.x, paddleRight.y, paddleRight.w, paddleRight.h, 6);

                // ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fill();

                // scores
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = 'bold 42px system-ui, Arial';
                ctx.textAlign = 'center';
                ctx.fillText(leftScore, GAME_W * 0.25, 70);
                ctx.fillText(rightScore, GAME_W * 0.75, 70);

                // small instructions or result
                if (!running && (leftScore >= WIN_SCORE || rightScore >= WIN_SCORE)) {
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.font = '28px system-ui, Arial';
                    const txt = leftScore > rightScore ? 'You Win! (R to restart)' : 'You Lose! (R to restart)';
                    ctx.fillText(txt, GAME_W / 2, GAME_H / 2);
                    ctx.font = '16px system-ui, Arial';
                    ctx.fillText('Press R to restart', GAME_W / 2, GAME_H / 2 + 28);
                }
            }

            // Main loop
            function loop(ts) {
                if (!lastTime) lastTime = ts;
                const dt = Math.min(0.033, (ts - lastTime) / 1000); // clamp dt to avoid big jumps
                lastTime = ts;

                update(dt);
                render();

                requestAnimationFrame(loop);
            }

            // Input handlers
            window.addEventListener('keydown', e => {
                if (e.key === 'ArrowUp' || e.key === 'Up' || e.key === 'w' || e.key === 'W') { keys.up = true; }
                if (e.key === 'ArrowDown' || e.key === 'Down' || e.key === 's' || e.key === 'S') { keys.down = true; }
                if (e.code === 'Space') { running = !running; document.getElementById('pauseBtn').textContent = running ? 'Pause' : 'Resume'; }
                if (e.key === 'r' || e.key === 'R') { leftScore = 0; rightScore = 0; running = true; resetBall(true); }
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'ArrowUp' || e.key === 'Up' || e.key === 'w' || e.key === 'W') { keys.up = false; }
                if (e.key === 'ArrowDown' || e.key === 'Down' || e.key === 's' || e.key === 'S') { keys.down = false; }
            });

            // Pointer/mouse control: move paddle by vertical position of pointer inside canvas
            function pointerToGame(e) {
                const rect = canvas.getBoundingClientRect();
                // support touch events
                const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : (e.clientY !== undefined ? e.clientY : (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : null));
                if (clientY === null) return null;
                const y = (clientY - rect.top) * (canvas.height / rect.height) / (window.devicePixelRatio || 1);
                return Math.max(0, Math.min(GAME_H, y));
            }

            canvas.addEventListener('mousemove', e => {
                pointerY = pointerToGame(e);
            });
            canvas.addEventListener('touchstart', e => { e.preventDefault(); pointerY = pointerToGame(e); });
            canvas.addEventListener('touchmove', e => { e.preventDefault(); pointerY = pointerToGame(e); });
            canvas.addEventListener('touchend', e => { pointerY = null; });
            canvas.addEventListener('mouseleave', () => { pointerY = null; });

            // Buttons
            document.getElementById('pauseBtn').addEventListener('click', () => {
                running = !running;
                document.getElementById('pauseBtn').textContent = running ? 'Pause' : 'Resume';
            });
            document.getElementById('restartBtn').addEventListener('click', () => {
                leftScore = 0; rightScore = 0; running = true; resetBall(true);
            });

            // Mobile on-screen buttons (for accessibility)
            document.getElementById('upBtn').addEventListener('touchstart', e => { e.preventDefault(); keys.up = true; });
            document.getElementById('upBtn').addEventListener('touchend', e => { e.preventDefault(); keys.up = false; });
            document.getElementById('downBtn').addEventListener('touchstart', e => { e.preventDefault(); keys.down = true; });
            document.getElementById('downBtn').addEventListener('touchend', e => { e.preventDefault(); keys.down = false; });

            // init
            resizeCanvas();
            resetBall(true);
            requestAnimationFrame(loop);
            window.addEventListener('resize', resizeCanvas);
        })();
    </script>
</body>

</html>
