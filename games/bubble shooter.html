<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0e7ff;
            /* Lighter blue background */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .back-btn-2 {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            font-size: 14px;
            background: #4a90e2;
            border: none;
            border-radius: 20px;
            color: white;
            text-decoration: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
        }

        .back-btn-2:hover {
            background: #357ae8;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 1.5rem;
            /* Increased padding */
            border-radius: 1rem;
            /* More rounded corners */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            width: 95vw;
            max-width: 500px;
            border: 2px solid #a78bfa;
            /* Subtle border for distinction */
        }

        h1 {
            font-size: 2.25rem;
            /* Larger title */
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 0.75rem;
            /* Increased margin */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
            /* Text shadow for title */
        }

        #ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0 0.75rem;
            /* Increased padding */
            margin-bottom: 1rem;
            /* Increased margin */
            font-size: 1.25rem;
            /* Larger UI text */
            font-weight: 700;
            color: #374151;
            /* Darker UI text */
        }

        #ui-bar>div {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            /* Increased gap */
        }

        #next-bubble-canvas {
            width: 45px;
            /* Slightly larger next bubble */
            height: 45px;
            background: #e5e7eb;
            border-radius: 50%;
            border: 2px solid #9ca3af;
            /* Border around next bubble */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            /* Inset shadow */
        }

        #game-canvas {
            background: linear-gradient(to bottom, #bfdbfe, #93c5fd);
            /* Gradient background for canvas */
            border-radius: 0.75rem;
            /* More rounded corners */
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="%233b82f6" stroke="%231d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-crosshair"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="2" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></svg>') 15 15, crosshair;
            /* Custom crosshair cursor */
            width: 100%;
            aspect-ratio: 10 / 12;
            max-height: 80vh;
            border: 1px solid #60a5fa;
            /* Border for the game area */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            /* Inset shadow for game area */
        }

        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(31, 41, 55, 0.85);
            /* Darker overlay */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 10;
            animation: fadeIn 0.5s ease-out;
            /* Fade in animation */
        }

        #game-over-box {
            background: linear-gradient(to bottom right, #fef2f2, #fee2e2);
            /* Gradient background for game over */
            color: #1f2937;
            padding: 3rem;
            /* More padding */
            border-radius: 1rem;
            /* More rounded corners */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            border: 2px solid #ef4444;
            /* Red border */
            animation: popIn 0.3s ease-out;
            /* Pop in animation */
        }

        #game-over-box h2 {
            font-size: 2.5rem;
            /* Larger game over title */
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #b91c1c;
            /* Darker red */
        }

        #game-over-box p {
            font-size: 1.25rem;
            /* Larger game over score text */
            margin-bottom: 2rem;
            color: #4b5563;
        }

        #restart-button {
            background-color: #4f46e5;
            /* Deeper blue for restart */
            color: white;
            font-weight: 700;
            padding: 1rem 2rem;
            /* Larger button */
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        #restart-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }

        #restart-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <h1>Bubble Shooter</h1>
        <div id="ui-bar">
            <div>Score: <span id="score">0</span></div>
            <div>Next: <canvas id="next-bubble-canvas"></canvas></div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>
    <a href="../index.html" class="back-btn-2">‚Üê Back</a>


    <div id="game-over-overlay">
        <div id="game-over-box">
            <h2>Game Over</h2>
            <p>Your final score is: <span id="final-score">0</span></p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // --- Get DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-bubble-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- Game Constants ---
        const COLS = 10;
        const ROWS = 15;
        const BUBBLE_RADIUS = 20;
        const BUBBLE_DIAMETER = BUBBLE_RADIUS * 2;
        const ROW_HEIGHT = BUBBLE_RADIUS * 1.732;
        const COLORS = [
            '#ef4444', // red-500
            '#f59e0b', // amber-500
            '#22c55e', // green-500
            '#3b82f6', // blue-500
            '#8b5cf6', // violet-500
            '#ec4899', // pink-500
        ];
        const SHOTS_PER_ROW_ADD = 5;

        // --- Game State ---
        let grid = [];
        let currentBubble = null;
        let nextBubble = null;
        let aimAngle = -Math.PI / 2;
        let score = 0;
        let shotsFired = 0;
        let gameOver = false;
        let scale = 1; // Keeping for potential future use, though not directly used for canvas scaling now
        let canvasWidth = 500;
        let canvasHeight = 600;
        let scaledRadius = BUBBLE_RADIUS;
        let scaledDiameter = BUBBLE_DIAMETER;
        let scaledRowHeight = ROW_HEIGHT;
        let shooterX = canvasWidth / 2;
        let shooterY = canvasHeight - 30;
        let gameOverLineY = canvasHeight - scaledDiameter * 2.5;
        let poppingBubbles = []; // Array to store bubbles that are popping

        // --- Bubble Class (for the moving bubble and grid bubbles) ---
        class Bubble {
            constructor(x, y, color, dx = 0, dy = 0) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = scaledRadius;
                this.dx = dx;
                this.dy = dy;
                this.speed = 15; // Speed is independent of scale for smoother movement
                this.isShooting = false;
                this.popAnimationProgress = 0; // 0 to 1 for popping animation
            }

            draw(context) {
                context.save(); // Save context state before applying shadows

                // Draw subtle shadow
                context.shadowColor = 'rgba(0, 0, 0, 0.4)';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;

                context.beginPath();
                // Create a more pronounced shine effect with a wider highlight
                const gradient = context.createRadialGradient(
                    this.x - this.radius * 0.4, // Highlight slightly offset
                    this.y - this.radius * 0.4,
                    this.radius * 0.2, // Smaller highlight circle
                    this.x,
                    this.y,
                    this.radius
                );
                gradient.addColorStop(0, 'rgba(255,255,255,0.9)'); // Brighter highlight
                gradient.addColorStop(0.6, this.color);
                gradient.addColorStop(1, this.color);

                context.fillStyle = gradient;
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fill();

                context.restore(); // Restore context state to remove shadows for other drawings
            }

            update() {
                if (!this.isShooting) return;

                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;

                // Wall collision (bounce)
                if (this.x - this.radius < 0 || this.x + this.radius > canvasWidth) {
                    this.dx = -this.dx;
                    // Ensure it's inside bounds
                    this.x = Math.max(this.radius, Math.min(canvasWidth - this.radius, this.x));
                }
            }
        }

        // --- Core Functions ---

        function init() {
            resizeCanvas();

            nextCanvas.width = 45; // Updated next bubble canvas size
            nextCanvas.height = 45;

            createGrid();
            loadBubbles();
            drawNextBubble();

            score = 0;
            shotsFired = 0;
            gameOver = false;
            poppingBubbles = []; // Clear any popping bubbles
            updateScore(0);
            gameOverOverlay.style.display = 'none';

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth - 48; // Account for 1.5rem padding on both sides (3rem total)

            scaledRadius = (containerWidth / COLS) / 2.1;
            scaledDiameter = scaledRadius * 2;
            scaledRowHeight = scaledRadius * 1.732;

            canvasWidth = containerWidth;
            canvasHeight = (scaledRowHeight * (ROWS - 3)) + scaledRadius * 2; // Keep canvas height relative

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            shooterY = canvasHeight - scaledRadius * 1.5;
            shooterX = canvasWidth / 2;
            gameOverLineY = canvasHeight - scaledRadius * 3;

            if (grid.length > 0) {
                // Restart game on resize to recalculate grid visually
                createGrid();
                loadBubbles();
                drawNextBubble();
            }
        }

        function createGrid() {
            grid = [];
            for (let r = 0; r < ROWS; r++) {
                let row = [];
                for (let c = 0; c < COLS; c++) {
                    if (r < 5) { // Populate top 5 rows initially
                        row.push(Math.random() < 0.7 ? getRandomColor() : 0);
                    } else {
                        row.push(0); // 0 = empty
                    }
                }
                grid.push(row);
            }
        }

        function loadBubbles() {
            if (!nextBubble) {
                currentBubble = new Bubble(shooterX, shooterY, getRandomColor());
            } else {
                currentBubble = new Bubble(shooterX, shooterY, nextBubble.color);
            }

            nextBubble = new Bubble(20, 20, getRandomColor());
            drawNextBubble();
        }

        function gameLoop() {
            if (gameOver) return;

            update();
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (currentBubble.isShooting) {
                currentBubble.update();
                checkCollisions();
            }

            // Update popping bubbles animation
            poppingBubbles = poppingBubbles.filter(bubble => {
                bubble.popAnimationProgress += 0.05; // Adjust speed of pop animation
                return bubble.popAnimationProgress < 1;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            drawGrid();
            drawGameOverLine();
            drawAimingLine();
            drawShooter();

            currentBubble.draw(ctx);

            // Draw popping bubbles
            poppingBubbles.forEach(bubble => drawPoppedBubble(bubble));
        }

        function drawNextBubble() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const tempBubble = new Bubble(nextCanvas.width / 2, nextCanvas.height / 2, nextBubble.color);
            tempBubble.radius = 18; // Fixed size for display in UI
            tempBubble.draw(nextCtx);
        }

        function drawGrid() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0) {
                        let [x, y] = getCanvasCoords(r, c);
                        const bubble = new Bubble(x, y, grid[r][c]);
                        bubble.draw(ctx);
                    }
                }
            }
        }

        function drawGameOverLine() {
            ctx.beginPath();
            ctx.strokeStyle = '#f87171'; // red-400
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.moveTo(0, gameOverLineY);
            ctx.lineTo(canvasWidth, gameOverLineY);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawAimingLine() {
            if (currentBubble.isShooting) return;

            ctx.save();
            ctx.strokeStyle = '#6b7280'; // gray-500
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 10]); // Longer dashes for aiming line
            ctx.lineCap = 'round'; // Rounded ends for dashes

            const endX = shooterX + Math.cos(aimAngle) * (canvasHeight * 0.8);
            const endY = shooterY + Math.sin(aimAngle) * (canvasHeight * 0.8);

            // Simulate bounces for the aiming line
            let startPoint = { x: shooterX, y: shooterY };
            let currentAngle = aimAngle;
            let pathLength = canvasHeight * 0.8; // Max length
            let bounces = 0;
            const maxBounces = 3;

            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);

            while (pathLength > 0 && bounces < maxBounces) {
                let segmentLength = pathLength;
                let hitWall = false;

                let nextX = startPoint.x + Math.cos(currentAngle) * segmentLength;
                let nextY = startPoint.y + Math.sin(currentAngle) * segmentLength;

                if (nextX < 0) {
                    segmentLength = (0 - startPoint.x) / Math.cos(currentAngle);
                    nextX = 0;
                    nextY = startPoint.y + Math.sin(currentAngle) * segmentLength;
                    currentAngle = Math.PI - currentAngle; // Reflect angle
                    hitWall = true;
                } else if (nextX > canvasWidth) {
                    segmentLength = (canvasWidth - startPoint.x) / Math.cos(currentAngle);
                    nextX = canvasWidth;
                    nextY = startPoint.y + Math.sin(currentAngle) * segmentLength;
                    currentAngle = Math.PI - currentAngle; // Reflect angle
                    hitWall = true;
                }

                ctx.lineTo(nextX, nextY);
                pathLength -= segmentLength;
                startPoint = { x: nextX, y: nextY };

                if (hitWall) {
                    bounces++;
                } else {
                    break; // No wall hit, done
                }
            }

            ctx.stroke();
            ctx.restore();
        }

        function drawShooter() {
            // Shooter base
            ctx.beginPath();
            ctx.fillStyle = '#6b7280'; // gray-500
            ctx.arc(shooterX, shooterY + scaledRadius * 0.5 + 5, scaledRadius, 0, Math.PI * 2);
            ctx.fill();

            // Shooter cannon
            ctx.save();
            ctx.translate(shooterX, shooterY);
            ctx.rotate(aimAngle + Math.PI / 2); // Rotate to aim
            ctx.fillStyle = '#4b5563'; // gray-700
            ctx.beginPath();
            ctx.rect(-scaledRadius * 0.2, -scaledRadius * 1.5, scaledRadius * 0.4, scaledRadius * 1.5);
            ctx.fill();
            ctx.restore();
        }

        // --- Game Logic ---

        function shootBubble() {
            if (currentBubble.isShooting || gameOver) return;

            currentBubble.dx = Math.cos(aimAngle);
            currentBubble.dy = Math.sin(aimAngle);
            currentBubble.isShooting = true;
        }

        function checkCollisions() {
            if (currentBubble.y - currentBubble.radius < 0) {
                currentBubble.y = currentBubble.radius;
                snapBubble();
                return;
            }

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0) {
                        const [bubbleX, bubbleY] = getCanvasCoords(r, c);
                        const dist = distance(currentBubble.x, currentBubble.y, bubbleX, bubbleY);

                        if (dist < scaledDiameter * 0.9) {
                            snapBubble();
                            return;
                        }
                    }
                }
            }
        }

        async function snapBubble() {
            currentBubble.isShooting = false;

            let [snapR, snapC] = findClosestEmptyCell(currentBubble.x, currentBubble.y);

            if (snapR === -1 || !isValid(snapR, snapC) || grid[snapR][snapC] !== 0) {
                [snapR, snapC] = findClosestEmptyCell(currentBubble.x, currentBubble.y, true);
                if (snapR === -1) {
                    triggerGameOver();
                    return;
                }
            }

            grid[snapR][snapC] = currentBubble.color;

            await sleep(50);

            const cluster = findCluster(snapR, snapC, currentBubble.color);
            let clusterPopped = false; // <-- ADDED THIS FLAG

            if (cluster.size >= 3) {
                cluster.forEach(cell => {
                    const [r, c] = cell.split(',').map(Number);
                    const [x, y] = getCanvasCoords(r, c);
                    poppingBubbles.push(new Bubble(x, y, grid[r][c])); // Add to popping array
                    grid[r][c] = 0;
                });
                updateScore(cluster.size * 10);
                clusterPopped = true; // <-- SET THE FLAG
            }

            // --- THIS IS THE FIX ---
            // Only check for floating bubbles if a cluster was actually popped.
            if (clusterPopped) {
                const floating = findFloatingBubbles();
                if (floating.size > 0) {
                    floating.forEach(cell => {
                        const [r, c] = cell.split(',').map(Number);
                        const [x, y] = getCanvasCoords(r, c);
                        poppingBubbles.push(new Bubble(x, y, grid[r][c])); // Add to popping array
                        grid[r][c] = 0;
                    });
                    updateScore(floating.size * 20);
                }
            }

            if (snapR * scaledRowHeight + scaledRadius > gameOverLineY) {
                triggerGameOver();
                return;
            }

            shotsFired++;
            if (shotsFired % SHOTS_PER_ROW_ADD === 0) {
                if (addNewRow()) {
                    triggerGameOver();
                    return;
                }
            }

            loadBubbles();
        }

        // Enhanced draw function for a popping bubble (simplified explosion)
        function drawPoppedBubble(bubble) {
            ctx.save();
            const progress = bubble.popAnimationProgress;
            const currentRadius = bubble.radius * (1 - progress); // Shrink
            const opacity = 1 - progress; // Fade out

            ctx.globalAlpha = opacity;
            ctx.beginPath();
            ctx.fillStyle = bubble.color;
            ctx.arc(bubble.x, bubble.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // Add small "particles"
            const numParticles = 5;
            for (let i = 0; i < numParticles; i++) {
                const angle = (Math.PI * 2 / numParticles) * i + progress * Math.PI; // Spin particles
                const particleRadius = currentRadius * 0.3 * (1 - progress);
                const particleDistance = bubble.radius * progress * 2; // Move particles outwards

                ctx.beginPath();
                ctx.arc(
                    bubble.x + Math.cos(angle) * particleDistance,
                    bubble.y + Math.sin(angle) * particleDistance,
                    particleRadius,
                    0, Math.PI * 2
                );
                ctx.fillStyle = bubble.color;
                ctx.fill();
            }

            ctx.restore();
        }

        function findCluster(startR, startC, color) {
            const cluster = new Set();
            const queue = [[startR, startC]];
            cluster.add(`${startR},${startC}`);

            while (queue.length > 0) {
                const [r, c] = queue.shift();
                const neighbors = getNeighbors(r, c);

                for (const [nr, nc] of neighbors) {
                    if (isValid(nr, nc) && !cluster.has(`${nr},${nc}`) && grid[nr][nc] === color) {
                        cluster.add(`${nr},${nc}`);
                        queue.push([nr, nc]);
                    }
                }
            }
            return cluster;
        }

        function findFloatingBubbles() {
            const floating = new Set();
            const connected = new Set();
            const queue = [];

            for (let c = 0; c < COLS; c++) {
                if (grid[0][c] !== 0) {
                    queue.push([0, c]);
                    connected.add(`0,${c}`);
                }
            }

            while (queue.length > 0) {
                const [r, c] = queue.shift();
                const neighbors = getNeighbors(r, c);

                for (const [nr, nc] of neighbors) {
                    if (isValid(nr, nc) && grid[nr][nc] !== 0 && !connected.has(`${nr},${nc}`)) {
                        connected.add(`${nr},${nc}`);
                        queue.push([nr, nc]);
                    }
                }
            }

            for (let r = 1; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0 && !connected.has(`${r},${c}`)) {
                        floating.add(`${r},${c}`);
                    }
                }
            }
            return floating;
        }

        function addNewRow() {
            let gameOverRisk = false;
            for (let c = 0; c < COLS; c++) {
                if (grid[ROWS - 4][c] !== 0) {
                    gameOverRisk = true;
                    break;
                }
            }

            grid.pop();

            let newRow = [];
            for (let c = 0; c < COLS; c++) {
                newRow.push(Math.random() < 0.7 ? getRandomColor() : 0);
            }
            grid.unshift(newRow);

            return gameOverRisk;
        }

        function triggerGameOver() {
            gameOver = true;
            finalScoreEl.textContent = score;
            gameOverOverlay.style.display = 'flex';
        }

        function resetGame() {
            init();
        }

        // --- Event Listeners ---

        function handleAim(e) {
            if (gameOver) return;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const dy = y - shooterY;
            const dx = x - shooterX;
            let angle = Math.atan2(dy, dx);

            const minAngle = -Math.PI * 0.95;
            const maxAngle = -Math.PI * 0.05;

            if (angle > maxAngle) angle = maxAngle;
            if (angle < minAngle) angle = minAngle;

            aimAngle = angle;
        }

        canvas.addEventListener('mousemove', handleAim);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleAim(e);
        }, { passive: false });

        canvas.addEventListener('click', shootBubble);
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            shootBubble();
        }, { passive: false });

        restartButton.addEventListener('click', resetGame);

        window.addEventListener('resize', () => {
            resetGame();
        });


        // --- Utility Functions ---
        function getCanvasCoords(r, c) {
            const x = c * (scaledRadius * 1.9) + (r % 2 === 1 ? scaledRadius : 0) + scaledRadius;
            const y = r * scaledRowHeight + scaledRadius;
            return [x, y];
        }

        function findClosestEmptyCell(x, y, forceFind = false) {
            let minDist = Infinity;
            let snapR = -1;
            let snapC = -1;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0 && !forceFind) continue;
                    if (grid[r][c] === 0 || forceFind) {
                        const [cellX, cellY] = getCanvasCoords(r, c);
                        const dist = distance(x, y, cellX, cellY);

                        if (cellY > gameOverLineY + scaledRadius) continue;

                        if (dist < minDist) {
                            minDist = dist;
                            snapR = r;
                            snapC = c;
                        }
                    }
                }
            }
            return [snapR, snapC];
        }

        function getNeighbors(r, c) {
            const isOddRow = r % 2 === 1;
            const neighborCoords = [
                [r - 1, c + (isOddRow ? 0 : -1)],
                [r - 1, c + (isOddRow ? 1 : 0)],
                [r, c - 1],
                [r, c + 1],
                [r + 1, c + (isOddRow ? 0 : -1)],
                [r + 1, c + (isOddRow ? 1 : 0)]
            ];

            return neighborCoords.filter(([nr, nc]) => isValid(nr, nc));
        }

        function isValid(r, c) {
            return r >= 0 && r < ROWS && c >= 0 && c < COLS;
        }

        function getRandomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function updateScore(points) {
            score += points;
            scoreEl.textContent = score;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- Start Game ---
        init();
    </script>
</body>

</html>