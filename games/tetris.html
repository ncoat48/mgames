<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Responsive Tetris</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      transition: all 0.3s ease;
    }

    .back-btn-2 {
      position: fixed;
      top: 15px;
      left: 15px;
      padding: 8px 16px;
      font-size: 14px;
      background: #4a90e2;
      border: none;
      border-radius: 20px;
      color: white;
      text-decoration: none;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-family: Arial, sans-serif;
    }

    .back-btn-2:hover {
      background: #357ae8;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    body.fullscreen {
      padding: 0;
      justify-content: flex-start;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 100%;
      transition: all 0.3s ease;
    }

    body.fullscreen .container {
      width: 100%;
      height: 100vh;
      justify-content: center;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-align: center;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      color: #e94560;
    }

    body.fullscreen h1 {
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      width: 100%;
    }

    body.fullscreen .game-container {
      gap: 10px;
      margin-bottom: 10px;
    }

    .game-board {
      width: 300px;
      height: 600px;
      background-color: rgba(0, 0, 0, 0.3);
      border: 2px solid #e94560;
      display: grid;
      grid-template-rows: repeat(20, 1fr);
      grid-template-columns: repeat(10, 1fr);
      box-shadow: 0 0 20px rgba(233, 69, 96, 0.3);
    }

    body.fullscreen .game-board {
      width: 280px;
      height: 560px;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 200px;
    }

    body.fullscreen .side-panel {
      width: 180px;
      gap: 10px;
    }

    .next-piece {
      background-color: rgba(0, 0, 0, 0.3);
      border: 2px solid #0f3460;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }

    body.fullscreen .next-piece {
      padding: 8px;
    }

    .next-piece-grid {
      width: 120px;
      height: 120px;
      margin: 10px auto;
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      grid-template-columns: repeat(4, 1fr);
      gap: 1px;
    }

    body.fullscreen .next-piece-grid {
      width: 100px;
      height: 100px;
    }

    .info-panel {
      background-color: rgba(0, 0, 0, 0.3);
      border: 2px solid #0f3460;
      padding: 15px;
      border-radius: 5px;
      text-align: center;
    }

    body.fullscreen .info-panel {
      padding: 10px;
    }

    .score,
    .level,
    .lines {
      margin: 10px 0;
      font-size: 1.2rem;
    }

    body.fullscreen .score,
    body.fullscreen .level,
    body.fullscreen .lines {
      font-size: 1rem;
      margin: 8px 0;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
      width: 100%;
      max-width: 500px;
    }

    .mobile-controls {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 10px;
      margin-top: 20px;
      width: 100%;
      max-width: 300px;
    }

    .control-btn {
      background-color: #0f3460;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 15px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: background-color 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover {
      background-color: #1a508b;
    }

    .control-btn:active {
      background-color: #e94560;
    }

    .rotate-btn {
      grid-column: 2;
      grid-row: 1;
    }

    .left-btn {
      grid-column: 1;
      grid-row: 2;
    }

    .down-btn {
      grid-column: 2;
      grid-row: 2;
    }

    .right-btn {
      grid-column: 3;
      grid-row: 2;
    }

    .drop-btn {
      grid-column: 2;
      grid-row: 3;
    }

    .start-btn {
      background-color: #e94560;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 15px 30px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-top: 10px;
    }

    .start-btn:hover {
      background-color: #ff6b81;
    }

    .fullscreen-btn {
      background-color: #0f3460;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .fullscreen-btn:hover {
      background-color: #1a508b;
    }

    .fullscreen-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }

    .instructions {
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #0f3460;
    }

    body.fullscreen .instructions {
      display: none;
    }

    .instructions h2 {
      color: #e94560;
      margin-bottom: 10px;
    }

    .instructions p {
      margin: 5px 0;
    }

    /* Tetromino colors */
    .cell {
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .cell.i {
      background-color: #00f0f0;
    }

    .cell.j {
      background-color: #0000f0;
    }

    .cell.l {
      background-color: #f0a000;
    }

    .cell.o {
      background-color: #f0f000;
    }

    .cell.s {
      background-color: #00f000;
    }

    .cell.t {
      background-color: #a000f0;
    }

    .cell.z {
      background-color: #f00000;
    }

    .cell.filled {
      background-color: #333;
    }

    /* Media queries for mobile */
    @media (max-width: 768px) {
      .game-container {
        flex-direction: column;
        align-items: center;
      }

      .side-panel {
        width: 300px;
        flex-direction: row;
        justify-content: space-between;
      }

      .mobile-controls {
        display: grid;
      }

      .instructions {
        font-size: 0.9rem;
      }

      body.fullscreen .side-panel {
        width: 300px;
        flex-direction: row;
      }

      body.fullscreen .game-board {
        width: 300px;
        height: 600px;
      }
    }

    @media (max-width: 480px) {
      body.fullscreen .game-board {
        width: 260px;
        height: 520px;
      }

      body.fullscreen .side-panel {
        width: 260px;
      }

      body.fullscreen .next-piece-grid {
        width: 80px;
        height: 80px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>TETRIS</h1>
    <a href="../index.html" class="back-btn-2">← Back</a>

    <div class="game-container">
      <div class="game-board" id="board"></div>

      <div class="side-panel">
        <div class="next-piece">
          <h3>NEXT</h3>
          <div class="next-piece-grid" id="next-piece"></div>
        </div>

        <div class="info-panel">
          <div class="score">SCORE: <span id="score">0</span></div>
          <div class="level">LEVEL: <span id="level">1</span></div>
          <div class="lines">LINES: <span id="lines">0</span></div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="start-btn" id="start-btn">START GAME</button>
      <button class="fullscreen-btn" id="fullscreen-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
        </svg>
        FULL SCREEN
      </button>
    </div>

    <div class="mobile-controls">
      <button class="control-btn rotate-btn">↻</button>
      <button class="control-btn left-btn">←</button>
      <button class="control-btn down-btn">↓</button>
      <button class="control-btn right-btn">→</button>
      <button class="control-btn drop-btn">DROP</button>
    </div>

    <div class="instructions">
      <h2>HOW TO PLAY</h2>
      <p><strong>PC:</strong> Use ← → keys to move, ↑ to rotate, ↓ to soft drop, SPACE to hard drop</p>
      <p><strong>Mobile:</strong> Use the on-screen controls</p>
      <p>Complete lines to score points. The game speeds up as you level up!</p>
    </div>
  </div>

  <script>
    // Game constants
    const COLS = 10;
    const ROWS = 20;
    const EMPTY = 'empty';

    // Tetromino shapes and colors
    const SHAPES = {
      I: {
        shape: [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        color: 'i'
      },
      J: {
        shape: [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0]
        ],
        color: 'j'
      },
      L: {
        shape: [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0]
        ],
        color: 'l'
      },
      O: {
        shape: [
          [1, 1],
          [1, 1]
        ],
        color: 'o'
      },
      S: {
        shape: [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0]
        ],
        color: 's'
      },
      T: {
        shape: [
          [0, 1, 0],
          [1, 1, 1],
          [0, 0, 0]
        ],
        color: 't'
      },
      Z: {
        shape: [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0]
        ],
        color: 'z'
      }
    };

    // Game variables
    let board = [];
    let currentPiece = null;
    let nextPiece = null;
    let score = 0;
    let level = 1;
    let lines = 0;
    let gameOver = false;
    let dropInterval = null;
    let isPaused = false;
    let isFullscreen = false;

    // DOM elements
    const boardElement = document.getElementById('board');
    const nextPieceElement = document.getElementById('next-piece');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const linesElement = document.getElementById('lines');
    const startButton = document.getElementById('start-btn');
    const fullscreenButton = document.getElementById('fullscreen-btn');
    const bodyElement = document.body;

    // Initialize the game board
    function initBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = [];
        for (let c = 0; c < COLS; c++) {
          board[r][c] = EMPTY;
        }
      }

      // Create the visual board
      boardElement.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.id = `${r}-${c}`;
          boardElement.appendChild(cell);
        }
      }
    }

    // Create a random tetromino
    function getRandomPiece() {
      const pieces = Object.keys(SHAPES);
      const randPiece = pieces[Math.floor(Math.random() * pieces.length)];
      return {
        shape: SHAPES[randPiece].shape,
        color: SHAPES[randPiece].color,
        row: 0,
        col: Math.floor(COLS / 2) - Math.floor(SHAPES[randPiece].shape[0].length / 2)
      };
    }

    // Draw the board
    function drawBoard() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.getElementById(`${r}-${c}`);
          cell.className = 'cell';

          if (board[r][c] !== EMPTY) {
            cell.classList.add(board[r][c]);
          }
        }
      }
    }

    // Draw the current piece
    function drawPiece() {
      if (!currentPiece) return;

      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (currentPiece.shape[r][c]) {
            const boardRow = currentPiece.row + r;
            const boardCol = currentPiece.col + c;

            if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
              const cell = document.getElementById(`${boardRow}-${boardCol}`);
              cell.classList.add(currentPiece.color);
            }
          }
        }
      }
    }

    // Draw the next piece preview
    function drawNextPiece() {
      nextPieceElement.innerHTML = '';

      if (!nextPiece) return;

      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');

          if (r < nextPiece.shape.length && c < nextPiece.shape[0].length && nextPiece.shape[r][c]) {
            cell.classList.add(nextPiece.color);
          }

          nextPieceElement.appendChild(cell);
        }
      }
    }

    // Check for collision
    function hasCollision(piece, rowOffset = 0, colOffset = 0) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            const newRow = piece.row + r + rowOffset;
            const newCol = piece.col + c + colOffset;

            if (
              newRow >= ROWS ||
              newCol < 0 ||
              newCol >= COLS ||
              (newRow >= 0 && board[newRow][newCol] !== EMPTY)
            ) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Lock the piece in place
    function lockPiece() {
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (currentPiece.shape[r][c]) {
            const boardRow = currentPiece.row + r;
            const boardCol = currentPiece.col + c;

            if (boardRow >= 0) {
              board[boardRow][boardCol] = currentPiece.color;
            }
          }
        }
      }

      // Check for completed lines
      checkLines();

      // Get next piece
      currentPiece = nextPiece;
      nextPiece = getRandomPiece();
      drawNextPiece();

      // Check if game is over
      if (hasCollision(currentPiece)) {
        gameOver = true;
        clearInterval(dropInterval);
        startButton.textContent = 'RESTART GAME';
        alert('Game Over! Your score: ' + score);
      }
    }

    // Move the piece
    function movePiece(rowOffset, colOffset) {
      if (!currentPiece || gameOver || isPaused) return;

      if (!hasCollision(currentPiece, rowOffset, colOffset)) {
        currentPiece.row += rowOffset;
        currentPiece.col += colOffset;
        draw();
        return true;
      }

      // If moving down and there's a collision, lock the piece
      if (rowOffset > 0) {
        lockPiece();
        draw();
      }

      return false;
    }

    // Rotate the piece
    function rotatePiece() {
      if (!currentPiece || gameOver || isPaused) return;

      // Create a deep copy of the current piece
      const rotatedPiece = JSON.parse(JSON.stringify(currentPiece));

      // Transpose the shape matrix
      for (let r = 0; r < rotatedPiece.shape.length; r++) {
        for (let c = 0; c < r; c++) {
          [rotatedPiece.shape[r][c], rotatedPiece.shape[c][r]] =
            [rotatedPiece.shape[c][r], rotatedPiece.shape[r][c]];
        }
      }

      // Reverse each row to get a clockwise rotation
      rotatedPiece.shape.forEach(row => row.reverse());

      // Check if rotation is valid
      if (!hasCollision(rotatedPiece)) {
        currentPiece.shape = rotatedPiece.shape;
        draw();
      }
    }

    // Hard drop the piece
    function hardDrop() {
      if (!currentPiece || gameOver || isPaused) return;

      while (movePiece(1, 0)) {
        // Continue moving down until collision
      }
    }

    // Check for completed lines
    function checkLines() {
      let linesCleared = 0;

      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== EMPTY)) {
          // Remove the completed line
          board.splice(r, 1);
          // Add a new empty line at the top
          board.unshift(Array(COLS).fill(EMPTY));
          linesCleared++;
          r++; // Check the same row again after shifting
        }
      }

      if (linesCleared > 0) {
        // Update score
        const points = [0, 40, 100, 300, 1200][linesCleared] * level;
        score += points;
        lines += linesCleared;
        level = Math.floor(lines / 10) + 1;

        // Update UI
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;

        // Increase game speed
        clearInterval(dropInterval);
        dropInterval = setInterval(() => movePiece(1, 0), 1000 - (level - 1) * 100);
      }
    }

    // Draw the game state
    function draw() {
      drawBoard();
      drawPiece();
    }

    // Toggle fullscreen mode
    function toggleFullscreen() {
      if (!isFullscreen) {
        // Enter fullscreen
        if (bodyElement.requestFullscreen) {
          bodyElement.requestFullscreen();
        } else if (bodyElement.webkitRequestFullscreen) {
          bodyElement.webkitRequestFullscreen();
        } else if (bodyElement.msRequestFullscreen) {
          bodyElement.msRequestFullscreen();
        }

        bodyElement.classList.add('fullscreen');
        fullscreenButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                    </svg>
                    EXIT FULL SCREEN
                `;
        isFullscreen = true;
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }

        bodyElement.classList.remove('fullscreen');
        fullscreenButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                    </svg>
                    FULL SCREEN
                `;
        isFullscreen = false;
      }
    }

    // Start the game
    function startGame() {
      if (gameOver) {
        // Reset game state
        score = 0;
        level = 1;
        lines = 0;
        gameOver = false;
        isPaused = false;

        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;

        startButton.textContent = 'PAUSE GAME';
      } else if (isPaused) {
        // Resume game
        isPaused = false;
        startButton.textContent = 'PAUSE GAME';
        dropInterval = setInterval(() => movePiece(1, 0), 1000 - (level - 1) * 100);
      } else {
        // Pause game
        isPaused = true;
        startButton.textContent = 'RESUME GAME';
        clearInterval(dropInterval);
      }

      if (!currentPiece) {
        initBoard();
        nextPiece = getRandomPiece();
        currentPiece = getRandomPiece();
        drawNextPiece();
        draw();

        dropInterval = setInterval(() => movePiece(1, 0), 1000);
      }
    }

    // Initialize the game
    function init() {
      initBoard();
      draw();

      // Event listeners
      startButton.addEventListener('click', startGame);
      fullscreenButton.addEventListener('click', toggleFullscreen);

      // Fullscreen change event
      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
          bodyElement.classList.remove('fullscreen');
          fullscreenButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                        </svg>
                        FULL SCREEN
                    `;
          isFullscreen = false;
        }
      });

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (gameOver || isPaused) return;

        switch (e.key) {
          case 'ArrowLeft':
            movePiece(0, -1);
            break;
          case 'ArrowRight':
            movePiece(0, 1);
            break;
          case 'ArrowDown':
            movePiece(1, 0);
            break;
          case 'ArrowUp':
            rotatePiece();
            break;
          case ' ':
            hardDrop();
            break;
        }
      });

      // Mobile controls
      document.querySelector('.rotate-btn').addEventListener('click', rotatePiece);
      document.querySelector('.left-btn').addEventListener('click', () => movePiece(0, -1));
      document.querySelector('.right-btn').addEventListener('click', () => movePiece(0, 1));
      document.querySelector('.down-btn').addEventListener('click', () => movePiece(1, 0));
      document.querySelector('.drop-btn').addEventListener('click', hardDrop);

      // Prevent scrolling on mobile when using controls
      document.querySelectorAll('.control-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
        });
      });
    }

    // Start the game when the page loads
    window.onload = init;
  </script>
</body>

</html>
