<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fever Tetris ‚Äî Addictive Variant</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #0f1724;
      --accent: #00e5a8;
      --muted: #9aa9bf
    }

    * {
      box-sizing: border-box;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, 'Helvetica Neue', Arial
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #061025 0%, #000814 100%);
      color: #e6eef8
    }

    .back-btn-2 {
      position: fixed;
      top: 15px;
      left: 15px;
      padding: 8px 16px;
      font-size: 14px;
      background: #4a90e2;
      border: none;
      border-radius: 20px;
      color: white;
      text-decoration: none;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-family: Arial, sans-serif;
    }

    .back-btn-2:hover {
      background: #357ae8;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .container {
      display: grid;
      grid-template-columns: 340px 1fr 260px;
      gap: 20px;
      align-items: start;
      padding: 28px;
      max-width: 1200px;
      margin: 0 auto
    }

    .panel {
      background: linear-gradient(180deg, var(--panel), #08101a);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 8px 30px rgba(2, 6, 23, .6)
    }

    .title {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px
    }

    .title h1 {
      font-size: 18px;
      margin: 0
    }

    .controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .btn {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, .06);
      padding: 6px 10px;
      border-radius: 8px;
      color: var(--muted);
      cursor: pointer
    }

    .grid-wrap {
      display: flex;
      justify-content: center
    }

    #playfield {
      background: #041024;
      border-radius: 8px;
      padding: 8px
    }

    canvas {
      display: block;
      background: transparent
    }

    .stats {
      display: flex;
      flex-direction: column;
      gap: 10px
    }

    .stat {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent)
    }

    .small {
      font-size: 12px;
      color: var(--muted)
    }

    .queue {
      display: grid;
      grid-template-rows: repeat(5, 46px);
      gap: 8px;
      align-items: start
    }

    .queue canvas {
      width: 100%;
      height: 100%;
      border-radius: 6px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent)
    }

    .hold {
      height: 130px;
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .hold canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent)
    }

    .footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px
    }

    .legend {
      font-size: 12px;
      color: var(--muted)
    }

    .fever-bar {
      height: 12px;
      border-radius: 8px;
      background: linear-gradient(90deg, #132435, #0b2030);
      overflow: hidden
    }

    .fever-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff7bd6, #ffd86a);
      transition: width .2s ease
    }

    .combo {
      font-weight: 700;
      color: #ffd86a
    }

    .center-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px
    }

    .hints {
      font-size: 13px;
      color: var(--muted);
      text-align: center
    }

    .overlay-flash {
      position: fixed;
      inset: 0;
      pointer-events: none;
      border-radius: 0
    }

    /* responsive */
    @media (max-width:900px) {
      .container {
        grid-template-columns: 1fr;
        padding: 14px
      }

      .panel {
        padding: 12px
      }
    }
  </style>
</head>

<body>
  <a href="../index.html" class="back-btn-2">‚Üê Back</a>

  <div class="container">
    <div class="panel">
      <div class="title">
        <h1>Fever Tetris ‚Äî addictive variant</h1>
        <div style="margin-left:auto" class="small">Made for focus & combos</div>
      </div>
      <div class="controls">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="resetBtn" class="btn">Reset</button>
        <button id="soundBtn" class="btn">üîä Sound</button>
      </div>
      <hr style="opacity:.06;margin:12px 0">
      <div class="stats">
        <div class="stat">
          <div>Score</div>
          <div id="score">0</div>
        </div>
        <div class="stat">
          <div>Level</div>
          <div id="level">1</div>
        </div>
        <div class="stat">
          <div>Lines</div>
          <div id="lines">0</div>
        </div>
        <div class="stat">
          <div>Combo</div>
          <div id="combo">x0</div>
        </div>
        <div class="stat">
          <div>Fever</div>
          <div style="width:60%">
            <div class="fever-bar">
              <div id="feverFill" class="fever-fill"></div>
            </div>
          </div>
        </div>
      </div>
      <div style="margin-top:12px" class="legend">
        Controls: ‚Üê ‚Üí (move) | Z / X (rotate) | ‚Üì (soft drop) | Space (hard drop) | C (hold) | P (pause)
      </div>
    </div>

    <div class="panel center-panel">
      <div class="grid-wrap" id="gameArea">
        <div id="playfield">
          <canvas id="board" width="240" height="480"></canvas>
        </div>
      </div>
      <div class="hints small">Clear lines to build the Fever meter. Enter Fever mode for big multipliers, screen shake
        and particles. Aim for combos!</div>
      <div style="width:100%" class="footer">
        <div class="small">Best: <span id="best">0</span></div>
        <div class="small">Made with ‚ù§Ô∏è ‚Äî press start</div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;gap:12px;align-items:start">
        <div style="flex:1">
          <div class="small" style="margin-bottom:6px">Hold</div>
          <div class="hold"><canvas id="holdCanvas" width="140" height="120"></canvas></div>
        </div>
        <div style="width:140px">
          <div class="small" style="margin-bottom:6px">Next</div>
          <div class="queue">
            <canvas id="n1" width="140" height="46"></canvas>
            <canvas id="n2" width="140" height="46"></canvas>
            <canvas id="n3" width="140" height="46"></canvas>
            <canvas id="n4" width="140" height="46"></canvas>
            <canvas id="n5" width="140" height="46"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
  <canvas id="fx" class="overlay-flash" width="1200" height="800" style="mix-blend-mode:screen"></canvas>
  <script>
    (() => {
      // ------------------ Config & utilities
      const COLS = 10, ROWS = 20, BLOCK = 24; // scale
      const boardW = COLS * BLOCK, boardH = ROWS * BLOCK;
      const canvas = document.getElementById('board');
      canvas.width = boardW; canvas.height = boardH;
      const ctx = canvas.getContext('2d');

      // next/hold canvases
      const nextCanvases = ['n1', 'n2', 'n3', 'n4', 'n5'].map(id => document.getElementById(id));
      const holdCanvas = document.getElementById('holdCanvas');
      const fx = document.getElementById('fx'); fx.width = innerWidth; fx.height = innerHeight; const fxCtx = fx.getContext('2d');

      // DOM
      const startBtn = document.getElementById('startBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');
      const soundBtn = document.getElementById('soundBtn');
      const scoreEl = document.getElementById('score'), linesEl = document.getElementById('lines'), levelEl = document.getElementById('level'), comboEl = document.getElementById('combo'), feverFill = document.getElementById('feverFill'), bestEl = document.getElementById('best');

      // audio engine
      let audioEnabled = true;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const actx = new AudioCtx();
      function beep(freq, dur = 0.06, vol = 0.12) { if (!audioEnabled) return; try { const o = actx.createOscillator(), g = actx.createGain(); o.connect(g); g.connect(actx.destination); o.type = 'sine'; o.frequency.value = freq; g.gain.value = vol; o.start(); o.stop(actx.currentTime + dur); } catch (e) { console.warn(e) } }

      soundBtn.onclick = () => { audioEnabled = !audioEnabled; soundBtn.textContent = audioEnabled ? 'üîä Sound' : 'üîà Muted' };

      // pieces (tetromino matrices and colors)
      const SHAPES = {
        I: { m: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], c: '#5fefff' },
        J: { m: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], c: '#6fa8ff' },
        L: { m: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], c: '#ffb86b' },
        O: { m: [[1, 1], [1, 1]], c: '#ffd86a' },
        S: { m: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], c: '#7bff93' },
        T: { m: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], c: '#c88dff' },
        Z: { m: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], c: '#ff6b8a' }
      };
      const PIECES = Object.keys(SHAPES);

      // board state
      let grid, cur, bag, queue, hold = null, canHold = true, score = 0, lines = 0, level = 1, combo = 0, best = 0, fever = 0, feverMode = false;
      let tickInterval = 800, lastTick = 0, running = false, paused = false;

      function resetGame() {
        grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        bag = [];
        queue = [];
        refillQueue();
        spawn();
        canHold = true; score = 0; lines = 0; level = 1; combo = 0; fever = 0; feverMode = false; tickInterval = 800; running = true; paused = false; saveBest();
        updateUI(); clearFx(); playFlash();
      }

      function saveBest() { best = Math.max(best, score); localStorage.setItem('fever-tetris-best', best); bestEl.textContent = localStorage.getItem('fever-tetris-best') || 0 }
      if (localStorage.getItem('fever-tetris-best')) best = localStorage.getItem('fever-tetris-best'); bestEl.textContent = best || 0;

      function refillQueue() { while (queue.length < 6) { if (!bag.length) bag = shuffle(PIECES.slice()); queue.push(bag.pop()); } }
      function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]] } return a }

      function spawn() { refillQueue(); const k = queue.shift(); cur = makePiece(k); refillQueue(); canHold = true; }
      function makePiece(type) { const shape = SHAPES[type]; const matrix = shape.m.map(r => r.slice()); return { type, matrix, x: Math.floor((COLS - matrix[0].length) / 2), y: -matrix.length + 1, color: shape.c, rot: 0 } }

      function rotate(matrix, dir = 1) { // simple rotation
        const N = matrix.length; const res = Array.from({ length: N }, () => Array(N).fill(0));
        for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) res[c][N - 1 - r] = matrix[r][c];
        return dir > 0 ? res : rotate(rotate(rotate(matrix, 1), 1), 1);
      }

      function place() { // lock piece
        const m = cur.matrix; for (let r = 0; r < m.length; r++) for (let c = 0; c < m[r].length; c++) if (m[r][c]) {
          const gy = cur.y + r; const gx = cur.x + c; if (gy >= 0) grid[gy][gx] = { color: cur.color }; else { // game over
            running = false; playSound('gameover'); return
          }
        }
        // clear lines
        let cleared = 0; for (let r = ROWS - 1; r >= 0; r--) { if (grid[r].every(cell => cell)) { grid.splice(r, 1); grid.unshift(Array(COLS).fill(0)); cleared++; r++; } }
        if (cleared > 0) { handleClear(cleared); }
        else { combo = 0; }
        spawn(); canHold = true; playSound('lock');
      }

      function handleClear(c) { // scoring & fever
        const base = [0, 100, 250, 600, 1200]; const gain = base[c] || (c * 400);
        combo = combo + 1; const comboBonus = combo > 1 ? combo * 50 : 0; let feverGain = c * 12 + combo * 2;
        if (feverMode) feverGain *= 2;
        fever = Math.min(100, fever + feverGain);

        // level & scoring
        score += Math.floor((gain + comboBonus) * (feverMode ? 2 : 1) * (1 + (level - 1) * 0.2));
        lines += c; level = Math.floor(lines / 10) + 1; tickInterval = Math.max(80, 800 - (level - 1) * 60);
        // big fevers on tetris
        if (c === 4) fever = Math.min(100, fever + 20);
        // if fever full -> trigger
        if (fever >= 100) triggerFever();
        playSound('clear' + c);
        updateUI(); spawnParticles(c);
      }

      function triggerFever() { fever = 0; feverMode = true; playSound('fever'); flashScreen(); setTimeout(() => { feverMode = false; }, 7000); }

      function playSound(name) { if (!audioEnabled) return; if (name.startsWith('clear')) { beep(400 + Math.random() * 300, 0.06, 0.12); } else if (name === 'lock') { beep(220, 0.04, 0.08); } else if (name === 'gameover') { beep(120, 0.6, 0.18); } else if (name === 'fever') { beep(900, 0.18, 0.18); } }

      function spawnParticles(cleared) { const count = 8 + cleared * 6; for (let i = 0; i < count; i++) { particles.push({ x: (cur.x + cur.matrix[0].length / 2) * BLOCK + (Math.random() - 0.5) * 40, y: (cur.y + 1) * BLOCK + (Math.random() - 0.5) * 40, vx: (Math.random() - 0.5) * 6, vy: -Math.random() * 6, life: 60 + Math.random() * 30, col: randomColor() }) } }
      function randomColor() { const cols = Object.values(SHAPES).map(s => s.c); return cols[Math.floor(Math.random() * cols.length)]; }

      // particles
      const particles = [];
      function updateParticles() { fxCtx.clearRect(0, 0, fx.width, fx.height); for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.vy += 0.18; p.x += p.vx; p.y += p.vy; p.life--; fxCtx.globalAlpha = Math.max(0, p.life / 80); fxCtx.fillStyle = p.col; fxCtx.beginPath(); fxCtx.arc(p.x + 200, p.y + 60, 4, 0, Math.PI * 2); fxCtx.fill(); if (p.life <= 0) particles.splice(i, 1); } fxCtx.globalAlpha = 1 }

      function clearFx() { fxCtx.clearRect(0, 0, fx.width, fx.height); particles.length = 0 }
      function flashScreen() { fxCtx.fillStyle = 'rgba(255,255,255,0.06)'; fxCtx.fillRect(0, 0, fx.width, fx.height); }
      function playFlash() { // tiny intro ripple
        for (let i = 0; i < 10; i++) particles.push({ x: Math.random() * 200, y: Math.random() * 200, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, life: 30 + Math.random() * 40, col: randomColor() });
      }

      // movement & collision
      function collide(mx, my, matrix) {
        for (let r = 0; r < matrix.length; r++) for (let c = 0; c < matrix[r].length; c++) if (matrix[r][c]) {
          const x = mx + c; const y = my + r; if (x < 0 || x >= COLS || y >= ROWS) return true; if (y >= 0 && grid[y][x]) return true;
        } return false
      }

      function hardDrop() { while (!collide(cur.x, cur.y + 1, cur.matrix)) cur.y++; place(); score += 2 * (level); playSound('lock'); updateUI(); }

      function move(dx) { if (!collide(cur.x + dx, cur.y, cur.matrix)) cur.x += dx; else { beep(120, 0.02, 0.06) } }
      function softDrop() { if (!collide(cur.x, cur.y + 1, cur.matrix)) { cur.y++; score += 1; } else { place(); } }

      function rotateCur(dir = 1) {
        const nm = rotate(cur.matrix, dir); // wall kicks (simple)
        const kicks = [0, -1, 1, -2, 2]; for (let k of kicks) { if (!collide(cur.x + k, cur.y, nm)) { cur.matrix = nm; cur.x += k; return; } }
        beep(160, 0.02, 0.06);
      }

      function holdPiece() { if (!canHold) return; if (hold) { const t = hold; hold = cur.type; cur = makePiece(t); } else { hold = cur.type; spawn(); } canHold = false; playSound('lock'); updateUI(); }

      // draw functions
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // grid background
        ctx.fillStyle = '#071226'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        // draw cells
        for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
          const cell = grid[r][c]; if (cell) { drawBlock(c * BLOCK, r * BLOCK, cell.color); }
        }
        // ghost projection
        const ghostY = calcGhostY(); drawGhost(cur.x, ghostY, cur.matrix);
        // current
        const m = cur.matrix; for (let r = 0; r < m.length; r++) for (let c = 0; c < m[r].length; c++) if (m[r][c]) drawBlock((cur.x + c) * BLOCK, (cur.y + r) * BLOCK, cur.color, true);
        // grid lines (subtle)
        ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1; for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, canvas.height); ctx.stroke(); }
      }

      function drawBlock(x, y, color, solid = false) {
        const pad = 2; ctx.fillStyle = color; ctx.fillRect(x + pad, y + pad, BLOCK - pad * 2, BLOCK - pad * 2);
        // glossy
        ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(x + pad, y + pad, BLOCK - pad * 2, (BLOCK - pad * 2) / 3);
        ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.strokeRect(x + pad, y + pad, BLOCK - pad * 2, BLOCK - pad * 2);
      }

      function drawGhost(x, y, matrix) { ctx.save(); ctx.globalAlpha = 0.18; for (let r = 0; r < matrix.length; r++) for (let c = 0; c < matrix[r].length; c++) if (matrix[r][c]) drawBlock((x + c) * BLOCK, (y + r) * BLOCK, '#ffffff'); ctx.restore(); }

      function calcGhostY() { let gy = cur.y; while (!collide(cur.x, gy + 1, cur.matrix)) gy++; return gy; }

      function renderNext() { for (let i = 0; i < 5; i++) { const c = nextCanvases[i]; const ctxn = c.getContext('2d'); ctxn.clearRect(0, 0, c.width, c.height); const id = queue[i] || ''; if (!id) continue; drawMiniPiece(ctxn, id, c.width, c.height); } drawHold(); }
      function drawMiniPiece(ctxn, id, w, h) { ctxn.save(); ctxn.translate(w / 2, h / 2); ctxn.scale(1.6, 1.6); ctxn.translate(-w / 2, -h / 2); ctxn.fillStyle = SHAPES[id].c; ctxn.font = '600 20px monospace'; ctxn.textAlign = 'center'; ctxn.textBaseline = 'middle'; ctxn.fillText(id, w / 2, h / 2); ctxn.restore(); }
      function drawHold() { const ctxn = holdCanvas.getContext('2d'); ctxn.clearRect(0, 0, holdCanvas.width, holdCanvas.height); if (!hold) return; drawMiniPiece(ctxn, hold, holdCanvas.width, holdCanvas.height); }

      function updateUI() { scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level; comboEl.textContent = combo > 0 ? ('x' + combo) : 'x0'; feverFill.style.width = Math.min(100, fever) + '%'; renderNext(); saveBest(); }

      // main loop
      let acc = 0; let last = performance.now(); function loop(now) {
        if (!running) return; const dt = now - last; last = now; if (!paused) {
          acc += dt; while (acc > tickInterval) { acc -= tickInterval; if (!collide(cur.x, cur.y + 1, cur.matrix)) cur.y++; else { place(); } }
          updateParticles(); draw();
        }
        requestAnimationFrame(loop);
      }

      // input
      const keys = {};
      document.addEventListener('keydown', (e) => { if (!running) return; if (e.repeat) return; if (e.key === 'ArrowLeft') { move(-1); } else if (e.key === 'ArrowRight') { move(1); } else if (e.key === 'ArrowDown') { softDrop(); } else if (e.key === ' ') { hardDrop(); } else if (e.key === 'z' || e.key === 'Z') { rotateCur(-1); } else if (e.key === 'x' || e.key === 'X') { rotateCur(1); } else if (e.key === 'c' || e.key === 'C') { holdPiece(); } else if (e.key === 'p' || e.key === 'P') { togglePause(); } updateUI(); });

      // buttons
      startBtn.onclick = () => { if (!running) resetGame(); else { running = true; paused = false; last = performance.now(); requestAnimationFrame(loop); } };
      pauseBtn.onclick = () => { togglePause(); };
      resetBtn.onclick = () => { running = false; resetGame(); last = performance.now(); requestAnimationFrame(loop); };

      function togglePause() { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; if (!paused) { last = performance.now(); requestAnimationFrame(loop); } }

      // visual niceties
      function playSoundSimple() { beep(300, 0.02, 0.08); }

      // small gameplay tweak: soft lock after piece touches ground for N ticks
      // simplified: implement through tick step above

      // initial boot
      resetGame(); requestAnimationFrame(loop);

      // helpers for user experience
      window.addEventListener('resize', () => { fx.width = innerWidth; fx.height = innerHeight; });

      // quick tutorial overlay (console)
      console.log('Controls: ‚Üê ‚Üí move | Z/X rotate | ‚Üì soft drop | Space hard drop | C hold | P pause');

    })();
  </script>
</body>

</html>