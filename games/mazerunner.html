<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"> 
  <title>Maze Runner</title>
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #60a5fa;
      --accent-hover: #3b82f6;
      --muted: #94a3b8;
      --success: #16a34a;
      --player: #ffd166;
      --wall: #0b2030;
      --path: rgba(96, 165, 250, 0.18);
    }
    
    html, body {
      height: 100%;
      margin: 0;
      font-family: 'Inter', system-ui, Arial, sans-serif;
      background: linear-gradient(180deg, #071027 0%, #071b2b 100%);
      color: #e6eef8;
      overflow-x: hidden;
    }
    
    .app {
      max-width: 980px;
      margin: 18px auto;
      padding: 14px;
    }
    
    header {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }
    
    h1 {
      font-size: 24px;
      margin: 0;
      background: linear-gradient(90deg, #60a5fa, #a5b4fc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 16px;
      align-items: center;
    }
    
    .card {
      background: rgba(255, 255, 255, 0.03);
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(2, 6, 23, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    canvas {
      display: block;
      background: #021126;
      border-radius: 8px;
      width: 100%;
      height: auto;
      touch-action: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    label {
      font-size: 14px;
      color: var(--muted);
      font-weight: 500;
    }
    
    input[type=range] {
      width: 160px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: background 0.2s;
    }
    
    input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent-hover);
    }
    
    button {
      background: var(--accent);
      border: none;
      color: #021127;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    button:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .small {
      padding: 8px 12px;
      font-size: 14px;
    }
    
    .info {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }
    
    .touch-joy {
      display: none;
      margin-top: 16px;
      justify-content: center;
      gap: 12px;
    }
    
    .joybtn {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 12px;
      padding: 16px;
      min-width: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      transition: background 0.2s;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .joybtn:active {
      background: rgba(255, 255, 255, 0.08);
    }
    
    @media (max-width: 720px) {
      .touch-joy {
        display: flex;
      }
      
      .controls .row {
        justify-content: center;
      }
      
      .card {
        width: 100%;
      }
    }
    
    .footer {
      margin-top: 16px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }
    
    .win-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(11, 18, 32, 0.95);
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      z-index: 100;
      border: 1px solid rgba(96, 165, 250, 0.3);
      max-width: 300px;
      width: 80%;
      backdrop-filter: blur(10px);
      display: none;
    }
    
    .win-message h2 {
      margin-top: 0;
      color: var(--accent);
    }
    
    .win-message p {
      margin: 12px 0;
    }
    
    .win-message button {
      margin-top: 8px;
      width: 100%;
    }
    
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 99;
      display: none;
    }
    
    .stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      min-width: 80px;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: var(--accent);
    }
    
    .stat-label {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Maze Runner</h1>
        <div style="font-size:14px;color:var(--muted)">Generate a random maze and run to the green exit. Works on desktop & mobile.</div>
      </div>
    </header>

    <div class="controls">
      <div class="card">
        <div class="row">
          <label>Size (cells): <span id="sizeLabel">21</span></label>
          <input id="sizeRange" type="range" min="9" max="51" step="2" value="21">
          <button id="regen" class="small">Regenerate</button>
          <button id="solve" class="small">Show Solution</button>
          <button id="reset" class="small">Reset Player</button>
        </div>
      </div>
      <div class="card">
        <div class="stats">
          <div class="stat-item">
            <div class="stat-value" id="timer">0.0s</div>
            <div class="stat-label">Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="steps">0</div>
            <div class="stat-label">Steps</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="efficiency">0%</div>
            <div class="stat-label">Efficiency</div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <div class="touch-joy">
      <div class="joybtn" id="up">▲</div>
    </div>
    <div class="touch-joy">
      <div class="joybtn" id="left">◀</div>
      <div style="width:24px"></div>
      <div class="joybtn" id="right">▶</div>
    </div>
    <div class="touch-joy">
      <div class="joybtn" id="down">▼</div>
    </div>

    <div class="footer card">
      <p><strong>Controls:</strong> Arrow keys / WASD. On mobile use the on-screen buttons or swipe. Reach the green square to win.</p>
      <p style="margin-top: 8px;"><strong>Tip:</strong> Try to complete the maze with the fewest steps possible for a higher efficiency score!</p>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="win-message" id="winMessage">
    <h2>Congratulations!</h2>
    <p>You reached the exit!</p>
    <p><strong>Time:</strong> <span id="winTime">0.0s</span></p>
    <p><strong>Steps:</strong> <span id="winSteps">0</span></p>
    <p><strong>Efficiency:</strong> <span id="winEfficiency">0%</span></p>
    <button id="playAgain">Play Again</button>
  </div>

  <script>
  // Maze Runner - improved version
  (function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const sizeRange = document.getElementById('sizeRange');
    const sizeLabel = document.getElementById('sizeLabel');
    const regenBtn = document.getElementById('regen');
    const solveBtn = document.getElementById('solve');
    const resetBtn = document.getElementById('reset');
    const timerEl = document.getElementById('timer');
    const stepsEl = document.getElementById('steps');
    const efficiencyEl = document.getElementById('efficiency');
    const winMessage = document.getElementById('winMessage');
    const overlay = document.getElementById('overlay');
    const winTime = document.getElementById('winTime');
    const winSteps = document.getElementById('winSteps');
    const winEfficiency = document.getElementById('winEfficiency');
    const playAgainBtn = document.getElementById('playAgain');

    let cols = parseInt(sizeRange.value); // must be odd
    let rows = cols;

    sizeLabel.textContent = cols;

    let cellSize = 32;
    let maze; // 2D array of cells
    let player = {x:1,y:1};
    let exit = {x:cols-2,y:rows-2};
    let started = false;
    let startTime = 0;
    let steps = 0;
    let showSolution = false;
    let solutionPath = [];
    let optimalPathLength = 0;
    let animationFrameId = null;
    let particles = [];

    function resizeCanvas(){
      // fit canvas to container width while keeping square
      const container = canvas.parentElement;
      const size = Math.min(container.clientWidth - 28, 800);
      canvas.width = size;
      canvas.height = size;
      draw();
    }

    window.addEventListener('resize', resizeCanvas);

    function init(){
      cols = parseInt(sizeRange.value);
      if(cols % 2 === 0) cols += 1;
      rows = cols;
      sizeLabel.textContent = cols;
      cellSize = Math.floor(canvas.width / cols);
      maze = makeEmptyGrid(cols, rows);
      generateMaze();
      player = {x:1,y:1};
      exit = {x:cols-2,y:rows-2};
      started = false;
      steps = 0;
      solutionPath = [];
      showSolution = false;
      particles = [];
      solveBtn.textContent = 'Show Solution';
      calculateOptimalPath();
      updateHUD();
      draw();
    }

    function makeEmptyGrid(c,r){
      const g = [];
      for(let y=0;y<r;y++){
        const row=[];
        for(let x=0;x<c;x++) row.push({x,y,walls:true,visited:false});
        g.push(row);
      }
      return g;
    }

    // Recursive backtracker on a fine grid where cells with odd coords are passage cells
    function generateMaze(){
      // We'll treat cells with odd indices as nodes, even indices as walls
      // Start at (1,1), carve passages to neighbors
      const stack = [];
      const cx = 1, cy = 1;
      maze[cy][cx].visited = true;
      stack.push(maze[cy][cx]);
      while(stack.length){
        const current = stack[stack.length-1];
        const x = current.x, y = current.y;
        const neighbors = [];
        const dirs = [ [0,-2],[2,0],[0,2],[-2,0] ];
        for(const d of dirs){
          const nx = x + d[0], ny = y + d[1];
          if(ny>0 && ny<rows && nx>0 && nx<cols && !maze[ny][nx].visited){
            neighbors.push({nx,ny,dx:d[0],dy:d[1]});
          }
        }
        if(neighbors.length){
          const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
          // knock down wall between
          const wx = x + pick.dx/2, wy = y + pick.dy/2;
          maze[wy][wx].walls = false;
          maze[pick.ny][pick.nx].walls = false;
          maze[pick.ny][pick.nx].visited = true;
          stack.push(maze[pick.ny][pick.nx]);
        } else {
          stack.pop();
        }
      }
      // ensure start and exit are open
      maze[1][1].walls = false;
      maze[rows-2][cols-2].walls = false;
    }

    function draw(){
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      cellSize = Math.floor(w/cols);
      
      // draw background
      ctx.fillStyle = '#021126';
      ctx.fillRect(0,0,w,h);
      
      // draw maze
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const cell = maze[y][x];
          const px = x*cellSize, py = y*cellSize;
          if(cell.walls){
            ctx.fillStyle = '#0b2030';
            ctx.fillRect(px,py,cellSize,cellSize);
            
            // Add texture to walls
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(px+1, py+1, cellSize-2, cellSize-2);
          }
        }
      }
      
      // draw solution if asked
      if(showSolution && solutionPath.length){
        ctx.fillStyle = 'rgba(96,165,250,0.18)';
        for(const p of solutionPath){
          ctx.fillRect(p.x*cellSize+2,p.y*cellSize+2,cellSize-4,cellSize-4);
        }
      }
      
      // draw exit with glow effect
      const exitX = exit.x*cellSize + cellSize/2;
      const exitY = exit.y*cellSize + cellSize/2;
      
      // Exit glow
      const gradient = ctx.createRadialGradient(exitX, exitY, 0, exitX, exitY, cellSize/2);
      gradient.addColorStop(0, 'rgba(22, 163, 74, 0.8)');
      gradient.addColorStop(1, 'rgba(22, 163, 74, 0)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(exit.x*cellSize, exit.y*cellSize, cellSize, cellSize);
      
      // Exit square
      ctx.fillStyle = '#16a34a';
      ctx.fillRect(exit.x*cellSize+2, exit.y*cellSize+2, cellSize-4, cellSize-4);
      
      // draw player
      const cxp = player.x*cellSize + cellSize/2;
      const cyp = player.y*cellSize + cellSize/2;
      
      // Player shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.arc(cxp+2, cyp+2, Math.max(4, cellSize*0.32), 0, Math.PI*2);
      ctx.fill();
      
      // Player
      ctx.fillStyle = '#ffd166';
      ctx.beginPath();
      ctx.arc(cxp, cyp, Math.max(4, cellSize*0.32), 0, Math.PI*2);
      ctx.fill();
      
      // Player highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(cxp - Math.max(4, cellSize*0.32)*0.3, cyp - Math.max(4, cellSize*0.32)*0.3, Math.max(4, cellSize*0.32)*0.4, 0, Math.PI*2);
      ctx.fill();
      
      // Draw particles
      drawParticles();
      
      // grid lines subtle
      ctx.strokeStyle = 'rgba(200,220,255,0.02)';
      ctx.lineWidth = 1;
      ctx.strokeRect(0,0,cols*cellSize,rows*cellSize);
    }

    function drawParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.02;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05; // gravity
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function createParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4 - 1,
          size: Math.random() * 3 + 1,
          life: 1,
          color: color
        });
      }
    }

    function canMove(nx,ny){
      if(nx<0||ny<0||nx>=cols||ny>=rows) return false;
      return !maze[ny][nx].walls;
    }

    function move(dx,dy){
      const nx = player.x + dx, ny = player.y + dy;
      if(canMove(nx,ny)){
        // Create movement particles
        createParticles(
          player.x*cellSize + cellSize/2,
          player.y*cellSize + cellSize/2,
          3,
          '#ffd166'
        );
        
        player.x = nx; 
        player.y = ny;
        steps++;
        if(!started){
          started=true; 
          startTime=performance.now();
        }
        updateHUD();
        draw();
        checkWin();
      }
    }

    function updateHUD(){
      stepsEl.textContent = steps;
      
      // Calculate efficiency (optimal path length / actual steps)
      const efficiency = optimalPathLength > 0 ? 
        Math.min(100, Math.round((optimalPathLength / steps) * 100)) : 0;
      efficiencyEl.textContent = `${efficiency}%`;
      
      if(started){
        const elapsed = (performance.now() - startTime)/1000;
        timerEl.textContent = elapsed.toFixed(1) + 's';
      } else {
        timerEl.textContent = '0.0s';
      }
    }

    function checkWin(){
      if(player.x === exit.x && player.y === exit.y){
        const elapsed = ((performance.now()-startTime)/1000).toFixed(2);
        const efficiency = optimalPathLength > 0 ? 
          Math.min(100, Math.round((optimalPathLength / steps) * 100)) : 0;
        
        // Create win particles
        for (let i = 0; i < 50; i++) {
          createParticles(
            exit.x*cellSize + cellSize/2,
            exit.y*cellSize + cellSize/2,
            1,
            i % 2 === 0 ? '#16a34a' : '#ffd166'
          );
        }
        
        draw();
        
        // Show win message after a short delay
        setTimeout(() => {
          winTime.textContent = `${elapsed}s`;
          winSteps.textContent = steps;
          winEfficiency.textContent = `${efficiency}%`;
          winMessage.style.display = 'block';
          overlay.style.display = 'block';
        }, 500);
      }
    }

    function hideWinMessage() {
      winMessage.style.display = 'none';
      overlay.style.display = 'none';
    }

    // keyboard
    window.addEventListener('keydown', e=>{
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key) || ['w','a','s','d'].includes(e.key)){
        e.preventDefault();
      }
      if(e.key==='ArrowUp' || e.key==='w') move(0,-1);
      if(e.key==='ArrowDown' || e.key==='s') move(0,1);
      if(e.key==='ArrowLeft' || e.key==='a') move(-1,0);
      if(e.key==='ArrowRight' || e.key==='d') move(1,0);
    });

    // touch buttons
    ['up','down','left','right'].forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener('touchstart', ev=>{ 
        ev.preventDefault(); 
        if(id==='up') move(0,-1); 
        if(id==='down') move(0,1); 
        if(id==='left') move(-1,0); 
        if(id==='right') move(1,0); 
      });
      el.addEventListener('mousedown', ev=>{ 
        ev.preventDefault(); 
        if(id==='up') move(0,-1); 
        if(id==='down') move(0,1); 
        if(id==='left') move(-1,0); 
        if(id==='right') move(1,0); 
      });
    });

    // swipe support on canvas
    let touchStart = null;
    canvas.addEventListener('touchstart', e=>{ 
      const t=e.changedTouches[0]; 
      touchStart={x:t.clientX,y:t.clientY,time:Date.now()}; 
    });
    
    canvas.addEventListener('touchend', e=>{
      const t=e.changedTouches[0]; 
      if(!touchStart) return; 
      const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y; 
      const adx=Math.abs(dx), ady=Math.abs(dy);
      if(Math.max(adx,ady) < 20) return; // tap
      if(adx>ady) dx>0? move(1,0): move(-1,0);
      else dy>0? move(0,1): move(0,-1);
      touchStart = null;
    });

    // mouse drag for desktop swipe-like control
    let dragStart = null;
    canvas.addEventListener('mousedown', e=>{ dragStart={x:e.clientX,y:e.clientY}; });
    canvas.addEventListener('mouseup', e=>{
      if(!dragStart) return; 
      const dx=e.clientX-dragStart.x, dy=e.clientY-dragStart.y; 
      const adx=Math.abs(dx), ady=Math.abs(dy);
      if(Math.max(adx,ady) < 10) return; 
      if(adx>ady) dx>0? move(1,0): move(-1,0); 
      else dy>0? move(0,1): move(0,-1);
      dragStart=null;
    });

    // controls
    sizeRange.addEventListener('input', ()=>{ 
      sizeLabel.textContent = sizeRange.value; 
    });
    
    regenBtn.addEventListener('click', ()=>{ 
      hideWinMessage();
      init(); 
    });
    
    resetBtn.addEventListener('click', ()=>{ 
      hideWinMessage();
      player={x:1,y:1}; 
      steps=0; 
      started=false; 
      startTime=0; 
      updateHUD(); 
      draw(); 
    });
    
    solveBtn.addEventListener('click', ()=>{ 
      if(showSolution){ 
        showSolution=false; 
        solutionPath=[]; 
        draw(); 
        solveBtn.textContent='Show Solution'; 
      } else { 
        solutionPath = findPath(); 
        showSolution=true; 
        draw(); 
        solveBtn.textContent='Hide Solution'; 
      } 
    });
    
    playAgainBtn.addEventListener('click', () => {
      hideWinMessage();
      init();
    });

    // simple BFS pathfinder
    function findPath(){
      const q = [];
      const visited = Array.from({length:rows}, ()=>Array(cols).fill(false));
      const parent = Array.from({length:rows}, ()=>Array(cols).fill(null));
      q.push({x:player.x,y:player.y}); 
      visited[player.y][player.x]=true;
      
      while(q.length){
        const cur = q.shift();
        if(cur.x===exit.x && cur.y===exit.y) break;
        const dirs = [[0,-1],[1,0],[0,1],[-1,0]];
        for(const d of dirs){
          const nx=cur.x+d[0], ny=cur.y+d[1];
          if(nx>=0 && ny>=0 && nx<cols && ny<rows && !visited[ny][nx] && !maze[ny][nx].walls){
            visited[ny][nx]=true; 
            parent[ny][nx]=cur; 
            q.push({x:nx,y:ny});
          }
        }
      }
      
      const path=[]; 
      let cur = {x:exit.x,y:exit.y};
      while(cur){ 
        path.push(cur); 
        cur = parent[cur.y] ? parent[cur.y][cur.x] : null; 
      }
      path.reverse();
      return path;
    }

    function calculateOptimalPath() {
      const path = findPath();
      optimalPathLength = path.length;
    }

    // auto update timer
    setInterval(()=>{ 
      if(started) {
        updateHUD();
        
        // Animate particles
        if (particles.length > 0) {
          draw();
        }
      }
    }, 100);

    // initial draw and responsive sizing
    resizeCanvas();
    init();

  })();
  </script>
</body>
</html>